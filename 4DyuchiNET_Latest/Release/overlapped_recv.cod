; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.30501.0 

	TITLE	E:\GitHub\Mso_Code\4DyuchiNET_Latest\overlapped_recv.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?GetMaxAvalibleBytesPerBucket@CDynamicMemoryContainer@@QAEKXZ ; CDynamicMemoryContainer::GetMaxAvalibleBytesPerBucket
PUBLIC	?SetMemory@CReadMemoryHandle@@QAEXPADK@Z	; CReadMemoryHandle::SetMemory
PUBLIC	?GetMemory@CReadMemoryHandle@@QAEPADXZ		; CReadMemoryHandle::GetMemory
PUBLIC	?GetMaxMemorySize@CReadMemoryHandle@@QAEKXZ	; CReadMemoryHandle::GetMaxMemorySize
PUBLIC	?GetReservedBytes@CReadMemoryHandle@@QAEKXZ	; CReadMemoryHandle::GetReservedBytes
PUBLIC	?GetEntryPtr@CReadMemoryHandle@@QAEPADXZ	; CReadMemoryHandle::GetEntryPtr
PUBLIC	?GetMaxTransferSize@COverlapped@@QAEHXZ		; COverlapped::GetMaxTransferSize
PUBLIC	?Initialize@COverlappedRecv@@QAEXXZ		; COverlappedRecv::Initialize
PUBLIC	?GetMaxBufferSize@COverlappedRecv@@QAEKXZ	; COverlappedRecv::GetMaxBufferSize
PUBLIC	?AllocBuffer@COverlappedRecv@@QAEHK@Z		; COverlappedRecv::AllocBuffer
PUBLIC	?Release@COverlappedRecv@@QAEXXZ		; COverlappedRecv::Release
PUBLIC	?PrepareRead@COverlappedRecv@@QAEHXZ		; COverlappedRecv::PrepareRead
PUBLIC	??0COverlappedRecv@@QAE@XZ			; COverlappedRecv::COverlappedRecv
PUBLIC	??1COverlappedRecv@@QAE@XZ			; COverlappedRecv::~COverlappedRecv
PUBLIC	?GetDMRead@CNetwork@@QAEPAVCDynamicMemoryContainer@@XZ ; CNetwork::GetDMRead
EXTRN	__imp__WSAGetLastError@0:PROC
EXTRN	__imp__WSARecv@28:PROC
EXTRN	?Alloc@CDynamicMemoryContainer@@QAEPADXZ:PROC	; CDynamicMemoryContainer::Alloc
EXTRN	?Free@CDynamicMemoryContainer@@QAEXPAD@Z:PROC	; CDynamicMemoryContainer::Free
EXTRN	?InitializeMemory@CReadMemoryHandle@@QAEXXZ:PROC ; CReadMemoryHandle::InitializeMemory
EXTRN	??0CReadMemoryHandle@@QAE@XZ:PROC		; CReadMemoryHandle::CReadMemoryHandle
EXTRN	??1CReadMemoryHandle@@QAE@XZ:PROC		; CReadMemoryHandle::~CReadMemoryHandle
EXTRN	??0COverlapped@@QAE@XZ:PROC			; COverlapped::COverlapped
EXTRN	??1COverlapped@@QAE@XZ:PROC			; COverlapped::~COverlapped
EXTRN	?PostDisconnectEvent@@YAXK@Z:PROC		; PostDisconnectEvent
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1COverlappedRecv@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1COverlappedRecv@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1COverlappedRecv@@QAE@XZ$1
__ehfuncinfo$??1COverlappedRecv@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1COverlappedRecv@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0COverlappedRecv@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0COverlappedRecv@@QAE@XZ$0
__ehfuncinfo$??0COverlappedRecv@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0COverlappedRecv@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?GetDMRead@CNetwork@@QAEPAVCDynamicMemoryContainer@@XZ
_TEXT	SEGMENT
?GetDMRead@CNetwork@@QAEPAVCDynamicMemoryContainer@@XZ PROC ; CNetwork::GetDMRead, COMDAT
; _this$ = ecx
; File e:\github\mso_code\4dyuchinet_latest\network.h
; Line 74
  00000	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00003	c3		 ret	 0
?GetDMRead@CNetwork@@QAEPAVCDynamicMemoryContainer@@XZ ENDP ; CNetwork::GetDMRead
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1COverlappedRecv@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1COverlappedRecv@@QAE@XZ PROC				; COverlappedRecv::~COverlappedRecv, COMDAT
; _this$ = ecx
; File e:\github\mso_code\4dyuchinet_latest\overlapped_recv.cpp
; Line 73
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1COverlappedRecv@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx
  00027	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
; File e:\github\mso_code\4dyuchinet_latest\network.h
; Line 74
  0002a	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
; File e:\github\mso_code\4dyuchinet_latest\overlapped_recv.cpp
; Line 69
  0002d	ff 77 30	 push	 DWORD PTR [edi+48]
; Line 73
  00030	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
; Line 69
  00037	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  0003a	e8 00 00 00 00	 call	 ?Free@CDynamicMemoryContainer@@QAEXPAD@Z ; CDynamicMemoryContainer::Free
; Line 76
  0003f	8d 4f 30	 lea	 ecx, DWORD PTR [edi+48]
  00042	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00046	e8 00 00 00 00	 call	 ??1CReadMemoryHandle@@QAE@XZ ; CReadMemoryHandle::~CReadMemoryHandle
  0004b	8b cf		 mov	 ecx, edi
  0004d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00054	e8 00 00 00 00	 call	 ??1COverlapped@@QAE@XZ	; COverlapped::~COverlapped
  00059	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00063	59		 pop	 ecx
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1COverlappedRecv@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1COverlapped@@QAE@XZ	; COverlapped::~COverlapped
__unwindfunclet$??1COverlappedRecv@@QAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 30	 add	 ecx, 48			; 00000030H
  0000e	e9 00 00 00 00	 jmp	 ??1CReadMemoryHandle@@QAE@XZ ; CReadMemoryHandle::~CReadMemoryHandle
__ehhandler$??1COverlappedRecv@@QAE@XZ:
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1COverlappedRecv@@QAE@XZ
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1COverlappedRecv@@QAE@XZ ENDP				; COverlappedRecv::~COverlappedRecv
; Function compile flags: /Ogtp
;	COMDAT ??0COverlappedRecv@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0COverlappedRecv@@QAE@XZ PROC				; COverlappedRecv::COverlappedRecv, COMDAT
; _this$ = ecx
; File e:\github\mso_code\4dyuchinet_latest\overlapped_recv.cpp
; Line 6
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0COverlappedRecv@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	e8 00 00 00 00	 call	 ??0COverlapped@@QAE@XZ	; COverlapped::COverlapped
  0002e	8d 4e 30	 lea	 ecx, DWORD PTR [esi+48]
  00031	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00038	e8 00 00 00 00	 call	 ??0CReadMemoryHandle@@QAE@XZ ; CReadMemoryHandle::CReadMemoryHandle
; Line 13
  0003d	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
  00044	0f 57 c0	 xorps	 xmm0, xmm0
; Line 14
  00047	f3 0f 7f 06	 movdqu	 XMMWORD PTR [esi], xmm0
  0004b	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; Line 8
  00052	8b c6		 mov	 eax, esi
; Line 15
  00054	c7 46 1c ff ff
	ff ff		 mov	 DWORD PTR [esi+28], -1
; Line 16
  0005b	c7 46 14 02 00
	00 00		 mov	 DWORD PTR [esi+20], 2
; Line 17
  00062	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
; Line 18
  00069	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0
; Line 8
  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007a	59		 pop	 ecx
  0007b	5e		 pop	 esi
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0COverlappedRecv@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1COverlapped@@QAE@XZ	; COverlapped::~COverlapped
__ehhandler$??0COverlappedRecv@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0COverlappedRecv@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0COverlappedRecv@@QAE@XZ ENDP				; COverlappedRecv::COverlappedRecv
; Function compile flags: /Ogtp
;	COMDAT ?PrepareRead@COverlappedRecv@@QAEHXZ
_TEXT	SEGMENT
?PrepareRead@COverlappedRecv@@QAEHXZ PROC		; COverlappedRecv::PrepareRead, COMDAT
; _this$ = ecx
; File e:\github\mso_code\4dyuchinet_latest\overlapped_recv.cpp
; Line 42
  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx
; Line 53
  00004	6a 00		 push	 0
  00006	57		 push	 edi
  00007	8d 77 50	 lea	 esi, DWORD PTR [edi+80]
  0000a	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  0000d	8b 57 20	 mov	 edx, DWORD PTR [edi+32]
  00010	3b 57 40	 cmp	 edx, DWORD PTR [edi+64]
  00013	89 47 54	 mov	 DWORD PTR [edi+84], eax
  00016	8d 47 28	 lea	 eax, DWORD PTR [edi+40]
  00019	0f 47 57 40	 cmova	 edx, DWORD PTR [edi+64]
  0001d	50		 push	 eax
  0001e	8d 47 18	 lea	 eax, DWORD PTR [edi+24]
  00021	89 16		 mov	 DWORD PTR [esi], edx
  00023	50		 push	 eax
  00024	6a 01		 push	 1
  00026	56		 push	 esi
  00027	ff 77 1c	 push	 DWORD PTR [edi+28]
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSARecv@28
; Line 55
  00030	83 f8 ff	 cmp	 eax, -1
  00033	74 08		 je	 SHORT $LN2@PrepareRea
$LN14@PrepareRea:
  00035	5f		 pop	 edi
; Line 56
  00036	b8 01 00 00 00	 mov	 eax, 1
  0003b	5e		 pop	 esi
; Line 65
  0003c	c3		 ret	 0
$LN2@PrepareRea:
; Line 58
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
; Line 59
  00043	3d e5 03 00 00	 cmp	 eax, 997		; 000003e5H
  00048	74 eb		 je	 SHORT $LN14@PrepareRea
; Line 62
  0004a	ff 77 2c	 push	 DWORD PTR [edi+44]
  0004d	e8 00 00 00 00	 call	 ?PostDisconnectEvent@@YAXK@Z ; PostDisconnectEvent
  00052	83 c4 04	 add	 esp, 4
; Line 64
  00055	33 c0		 xor	 eax, eax
  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
; Line 65
  00059	c3		 ret	 0
?PrepareRead@COverlappedRecv@@QAEHXZ ENDP		; COverlappedRecv::PrepareRead
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?Release@COverlappedRecv@@QAEXXZ
_TEXT	SEGMENT
?Release@COverlappedRecv@@QAEXXZ PROC			; COverlappedRecv::Release, COMDAT
; _this$ = ecx
; File e:\github\mso_code\4dyuchinet_latest\overlapped_recv.cpp
; Line 69
  00000	ff 71 30	 push	 DWORD PTR [ecx+48]
  00003	8b 49 24	 mov	 ecx, DWORD PTR [ecx+36]
  00006	8b 49 6c	 mov	 ecx, DWORD PTR [ecx+108]
  00009	e8 00 00 00 00	 call	 ?Free@CDynamicMemoryContainer@@QAEXPAD@Z ; CDynamicMemoryContainer::Free
; Line 71
  0000e	c3		 ret	 0
?Release@COverlappedRecv@@QAEXXZ ENDP			; COverlappedRecv::Release
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?AllocBuffer@COverlappedRecv@@QAEHK@Z
_TEXT	SEGMENT
_size$ = 8						; size = 4
?AllocBuffer@COverlappedRecv@@QAEHK@Z PROC		; COverlappedRecv::AllocBuffer, COMDAT
; _this$ = ecx
; File e:\github\mso_code\4dyuchinet_latest\overlapped_recv.cpp
; Line 21
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; Line 25
  00003	83 7e 48 00	 cmp	 DWORD PTR [esi+72], 0
  00007	74 11		 je	 SHORT $LN2@AllocBuffe
; Line 27
  00009	8d 4e 30	 lea	 ecx, DWORD PTR [esi+48]
; File e:\github\mso_code\4dyuchinet_latest\read_memory_handle.h
; Line 36
  0000c	e8 00 00 00 00	 call	 ?InitializeMemory@CReadMemoryHandle@@QAEXXZ ; CReadMemoryHandle::InitializeMemory
; File e:\github\mso_code\4dyuchinet_latest\overlapped_recv.cpp
; Line 38
  00011	b8 01 00 00 00	 mov	 eax, 1
  00016	5e		 pop	 esi
; Line 39
  00017	c2 04 00	 ret	 4
$LN2@AllocBuffe:
; File e:\github\mso_code\4dyuchinet_latest\network.h
; Line 74
  0001a	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
; File e:\github\mso_code\4dyuchinet_latest\overlapped_recv.cpp
; Line 31
  0001d	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  00020	e8 00 00 00 00	 call	 ?Alloc@CDynamicMemoryContainer@@QAEPADXZ ; CDynamicMemoryContainer::Alloc
  00025	8b d0		 mov	 edx, eax
; Line 33
  00027	85 d2		 test	 edx, edx
  00029	75 04		 jne	 SHORT $LN1@AllocBuffe
  0002b	5e		 pop	 esi
; Line 39
  0002c	c2 04 00	 ret	 4
$LN1@AllocBuffe:
; File e:\github\mso_code\4dyuchinet_latest\dynamic_memory.h
; Line 30
  0002f	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
; File e:\github\mso_code\4dyuchinet_latest\overlapped_recv.cpp
; Line 36
  00032	8d 4e 30	 lea	 ecx, DWORD PTR [esi+48]
; File e:\github\mso_code\4dyuchinet_latest\dynamic_memory.h
; Line 30
  00035	8b 40 6c	 mov	 eax, DWORD PTR [eax+108]
  00038	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
; File e:\github\mso_code\4dyuchinet_latest\read_memory_handle.h
; Line 34
  0003b	89 11		 mov	 DWORD PTR [ecx], edx
; Line 35
  0003d	89 41 18	 mov	 DWORD PTR [ecx+24], eax
; Line 36
  00040	e8 00 00 00 00	 call	 ?InitializeMemory@CReadMemoryHandle@@QAEXXZ ; CReadMemoryHandle::InitializeMemory
; File e:\github\mso_code\4dyuchinet_latest\overlapped_recv.cpp
; Line 38
  00045	b8 01 00 00 00	 mov	 eax, 1
  0004a	5e		 pop	 esi
; Line 39
  0004b	c2 04 00	 ret	 4
?AllocBuffer@COverlappedRecv@@QAEHK@Z ENDP		; COverlappedRecv::AllocBuffer
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?GetMaxBufferSize@COverlappedRecv@@QAEKXZ
_TEXT	SEGMENT
?GetMaxBufferSize@COverlappedRecv@@QAEKXZ PROC		; COverlappedRecv::GetMaxBufferSize, COMDAT
; _this$ = ecx
; File e:\github\mso_code\4dyuchinet_latest\overlapped_recv.h
; Line 12
  00000	8b 41 48	 mov	 eax, DWORD PTR [ecx+72]
  00003	c3		 ret	 0
?GetMaxBufferSize@COverlappedRecv@@QAEKXZ ENDP		; COverlappedRecv::GetMaxBufferSize
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?Initialize@COverlappedRecv@@QAEXXZ
_TEXT	SEGMENT
?Initialize@COverlappedRecv@@QAEXXZ PROC		; COverlappedRecv::Initialize, COMDAT
; _this$ = ecx
; File e:\github\mso_code\4dyuchinet_latest\overlapped_recv.cpp
; Line 13
  00000	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0
  00007	0f 57 c0	 xorps	 xmm0, xmm0
; Line 14
  0000a	f3 0f 7f 01	 movdqu	 XMMWORD PTR [ecx], xmm0
  0000e	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
; Line 15
  00015	c7 41 1c ff ff
	ff ff		 mov	 DWORD PTR [ecx+28], -1
; Line 16
  0001c	c7 41 14 02 00
	00 00		 mov	 DWORD PTR [ecx+20], 2
; Line 17
  00023	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0
; Line 18
  0002a	c7 41 2c 00 00
	00 00		 mov	 DWORD PTR [ecx+44], 0
; Line 19
  00031	c3		 ret	 0
?Initialize@COverlappedRecv@@QAEXXZ ENDP		; COverlappedRecv::Initialize
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?GetMaxTransferSize@COverlapped@@QAEHXZ
_TEXT	SEGMENT
?GetMaxTransferSize@COverlapped@@QAEHXZ PROC		; COverlapped::GetMaxTransferSize, COMDAT
; _this$ = ecx
; File e:\github\mso_code\4dyuchinet_latest\overlapped.h
; Line 72
  00000	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00003	c3		 ret	 0
?GetMaxTransferSize@COverlapped@@QAEHXZ ENDP		; COverlapped::GetMaxTransferSize
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?GetEntryPtr@CReadMemoryHandle@@QAEPADXZ
_TEXT	SEGMENT
?GetEntryPtr@CReadMemoryHandle@@QAEPADXZ PROC		; CReadMemoryHandle::GetEntryPtr, COMDAT
; _this$ = ecx
; File e:\github\mso_code\4dyuchinet_latest\read_memory_handle.h
; Line 43
  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	c3		 ret	 0
?GetEntryPtr@CReadMemoryHandle@@QAEPADXZ ENDP		; CReadMemoryHandle::GetEntryPtr
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?GetReservedBytes@CReadMemoryHandle@@QAEKXZ
_TEXT	SEGMENT
?GetReservedBytes@CReadMemoryHandle@@QAEKXZ PROC	; CReadMemoryHandle::GetReservedBytes, COMDAT
; _this$ = ecx
; File e:\github\mso_code\4dyuchinet_latest\read_memory_handle.h
; Line 41
  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00003	c3		 ret	 0
?GetReservedBytes@CReadMemoryHandle@@QAEKXZ ENDP	; CReadMemoryHandle::GetReservedBytes
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?GetMaxMemorySize@CReadMemoryHandle@@QAEKXZ
_TEXT	SEGMENT
?GetMaxMemorySize@CReadMemoryHandle@@QAEKXZ PROC	; CReadMemoryHandle::GetMaxMemorySize, COMDAT
; _this$ = ecx
; File e:\github\mso_code\4dyuchinet_latest\read_memory_handle.h
; Line 40
  00000	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00003	c3		 ret	 0
?GetMaxMemorySize@CReadMemoryHandle@@QAEKXZ ENDP	; CReadMemoryHandle::GetMaxMemorySize
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?GetMemory@CReadMemoryHandle@@QAEPADXZ
_TEXT	SEGMENT
?GetMemory@CReadMemoryHandle@@QAEPADXZ PROC		; CReadMemoryHandle::GetMemory, COMDAT
; _this$ = ecx
; File e:\github\mso_code\4dyuchinet_latest\read_memory_handle.h
; Line 39
  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	c3		 ret	 0
?GetMemory@CReadMemoryHandle@@QAEPADXZ ENDP		; CReadMemoryHandle::GetMemory
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?SetMemory@CReadMemoryHandle@@QAEXPADK@Z
_TEXT	SEGMENT
_pBuffer$ = 8						; size = 4
_dwSize$ = 12						; size = 4
?SetMemory@CReadMemoryHandle@@QAEXPADK@Z PROC		; CReadMemoryHandle::SetMemory, COMDAT
; _this$ = ecx
; File e:\github\mso_code\4dyuchinet_latest\read_memory_handle.h
; Line 33
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; Line 34
  00003	8b 45 08	 mov	 eax, DWORD PTR _pBuffer$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
; Line 35
  00008	8b 45 0c	 mov	 eax, DWORD PTR _dwSize$[ebp]
  0000b	89 41 18	 mov	 DWORD PTR [ecx+24], eax
; Line 36
  0000e	e8 00 00 00 00	 call	 ?InitializeMemory@CReadMemoryHandle@@QAEXXZ ; CReadMemoryHandle::InitializeMemory
; Line 37
  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
?SetMemory@CReadMemoryHandle@@QAEXPADK@Z ENDP		; CReadMemoryHandle::SetMemory
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?GetMaxAvalibleBytesPerBucket@CDynamicMemoryContainer@@QAEKXZ
_TEXT	SEGMENT
?GetMaxAvalibleBytesPerBucket@CDynamicMemoryContainer@@QAEKXZ PROC ; CDynamicMemoryContainer::GetMaxAvalibleBytesPerBucket, COMDAT
; _this$ = ecx
; File e:\github\mso_code\4dyuchinet_latest\dynamic_memory.h
; Line 30
  00000	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00003	c3		 ret	 0
?GetMaxAvalibleBytesPerBucket@CDynamicMemoryContainer@@QAEKXZ ENDP ; CDynamicMemoryContainer::GetMaxAvalibleBytesPerBucket
_TEXT	ENDS
END
